import pygame
import numpy as np
import pyperclip

# Initialize Pygame
pygame.init()

# Constants
TILE_SIZE = 8
SCALE = 8  # Each pixel will be 8x8 screen pixels
TILES_PER_ROW = 8
TILES_PER_COL = 8
WINDOW_SIZE = TILE_SIZE * SCALE * TILES_PER_ROW
COLORS = {
    0: (255, 255, 255),  # White
    1: (192, 192, 192),  # Light gray
    2: (96, 96, 96),     # Dark gray
    3: (0, 0, 0)         # Black
}

# Example tile data - expanded to multiple tiles
EXAMPLE_TILES = [ 0x00,0x00,0x00,0x00,0x08,0x00,0x08,0x00,0x3E,0x00,0x08,0x00,0x08,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x18,0x00,0x18,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x7E,0x7E,0xE7,0x7E,0xE7,0x7E,0x81,0x7E,0x81,0x7E,0xE7,0x7E,0xE7,0x00,0x7E,
    0x00,0x7E,0x7E,0xFF,0x7E,0xFF,0x7E,0xC3,0x7E,0xC3,0x7E,0xFF,0x7E,0xFF,0x00,0x7E,
    0x7E,0x7E,0xC3,0xFF,0xA5,0xDB,0xA5,0xDB,0xBD,0xC3,0xA5,0xDB,0xC3,0xFF,0x7E,0x7E,
    0x7E,0x7E,0xC3,0xFF,0xD7,0xA9,0xD7,0xA9,0xF5,0x8B,0xD7,0xA9,0xC3,0xFF,0x7E,0x7E,
    0x7E,0x7E,0xC3,0xFF,0xA1,0xDF,0xA5,0xDB,0xA5,0xDB,0xB5,0xCB,0xC3,0xFF,0x7E,0x7E,
    0x7E,0x7E,0xE3,0x9F,0xD7,0xA9,0xF7,0x89,0xD5,0xAB,0xE7,0x99,0xC3,0xFF,0x7E,0x7E,
    0x7E,0x7E,0xC3,0xFF,0xB9,0xC7,0xA5,0xDB,0xBD,0xC3,0xA5,0xDB,0xFB,0xC7,0x7E,0x7E,
    0x7E,0x7E,0xC3,0xFF,0x9D,0xE3,0xA1,0xDF,0xA1,0xDF,0x9D,0xE3,0xC3,0xFF,0x7E,0x7E,
    0x7E,0x7E,0xC3,0xFF,0xA5,0xDB,0xB5,0xCB,0xAD,0xD3,0xA5,0xDB,0xC3,0xFF,0x7E,0x7E,
    0x7E,0x7E,0xC3,0xFF,0x99,0xE7,0xA5,0xDB,0xA5,0xDB,0x99,0xE7,0xC3,0xFF,0x7E,0x7E,
    0x7E,0x7E,0xC3,0xFF,0xBD,0xC3,0xA1,0xDF,0xBD,0xC3,0xA1,0xDF,0xC3,0xFF,0x7E,0x7E,
    0x7E,0x7E,0xFF,0xFF,0xBF,0xA9,0xDF,0x89,0xED,0xAB,0xFF,0xA9,0xFF,0xFF,0x7E,0x7E,
    0x7E,0x00,0xFF,0x00,0xFF,0x62,0xFF,0x55,0xFF,0x57,0xFF,0x55,0xFF,0x00,0x7E,0x00,
    0x7E,0x7E,0xC3,0xFF,0xB9,0xC1,0xD1,0xAB,0xD1,0xA9,0xD1,0xA9,0xC3,0xFF,0x7E,0x7E,
    0x7E,0x7E,0xC3,0xFF,0xF5,0x8B,0xD5,0xAB,0xF5,0x8B,0xD7,0xA9,0xC3,0xFF,0x7E,0x7E,
    0x7E,0x7E,0xC3,0xFF,0xB1,0xCF,0xA5,0xDB,0x95,0xEB,0xB5,0xCB,0xC3,0xFF,0x7E,0x7E,
    0x7E,0x7E,0xC3,0xFF,0xBD,0xC3,0xA5,0xDB,0xBD,0xC3,0xA1,0xDF,0xC3,0xFF,0x7E,0x7E,
    0x7E,0x7E,0xC3,0xFF,0x99,0xE7,0x91,0xEF,0x89,0xF7,0x99,0xE7,0xC3,0xFF,0x7E,0x7E,
    0x7E,0x7E,0xC3,0xFF,0xB5,0xCB,0xA5,0xDB,0xA5,0xDB,0xB7,0xC9,0xC3,0xFF,0x7E,0x7E,
    0x7E,0x7E,0xC3,0xFF,0xF1,0x8F,0xD7,0xA9,0xF5,0x8B,0xD5,0xAB,0xC3,0xFF,0x7E,0x7E,
    0x7E,0x7E,0xC3,0xFF,0x95,0xEB,0x99,0xE7,0x99,0xE7,0x95,0xEB,0xC3,0xFF,0x7E,0x7E,
    0x7E,0x7E,0xC3,0xFF,0xF7,0x89,0xC3,0xBD,0xC7,0xB9,0xF7,0x89,0xC3,0xFF,0x7E,0x7E,
    0x7E,0x7E,0xC3,0xFF,0xB7,0xC9,0xA5,0xDB,0x95,0xEB,0xB7,0xC9,0xC3,0xFF,0x7E,0x7E,
    0x7E,0x7E,0xC3,0xFF,0xF1,0x8F,0xA5,0xDB,0xA5,0xDB,0xA5,0xDB,0xC3,0xFF,0x7E,0x7E,
    0x7E,0x7E,0xC3,0xFF,0xA5,0xDB,0xA5,0xDB,0xBD,0xC3,0x99,0xE7,0xC3,0xFF,0x7E,0x7E,
    0x7E,0x7E,0xC3,0xFF,0xB1,0xCF,0xA7,0xD9,0xA5,0xDB,0xB5,0xCB,0xC3,0xFF,0x7E,0x7E,
    0x7E,0x7E,0xFF,0xFF,0xFF,0x5F,0xFF,0x29,0xFF,0x6A,0xFF,0x6A,0xFF,0xFF,0x7E,0x7E,
    0x7E,0x7E,0xC3,0xFF,0xB7,0xC9,0xA7,0xD9,0xB5,0xCB,0xA7,0xD9,0xC3,0xFF,0x7E,0x7E,
    0x7E,0x7E,0xC3,0xFF,0xE1,0x9F,0xCF,0xB1,0xCB,0xB5,0xEF,0x91,0xC3,0xFF,0x7E,0x7E,
    0x7E,0x7E,0xC3,0xFF,0xC9,0xB7,0xEB,0x95,0xDB,0xA5,0xCB,0xB5,0xC3,0xFF,0x7E,0x7E,
    0x7E,0x7E,0xC3,0xFF,0xE1,0x9F,0xCB,0xB5,0xCB,0xB5,0xEF,0x91,0xC3,0xFF,0x7E,0x7E,
    0x7E,0x7E,0xC3,0xFF,0xF1,0x8F,0xAF,0xD1,0xCB,0xB5,0xFB,0x85,0xC3,0xFF,0x7E,0x7E,
    0x7E,0x7E,0xC3,0xFF,0xF7,0x89,0xC3,0xBD,0xD7,0xA9,0xF7,0x89,0xC3,0xFF,0x7E,0x7E,
    0x7E,0x7E,0xFF,0xFF,0xFF,0x89,0xFF,0xB9,0xFF,0xAB,0xFF,0x89,0xFF,0xFF,0x7E,0x7E,
    0x7E,0x7E,0xC1,0xFF,0xA7,0xD9,0xD5,0xAB,0xF3,0x8D,0xD7,0xA9,0xC3,0xFF,0x7E,0x7E,
    0x7E,0x7E,0xC3,0xFF,0xB7,0xC9,0xA7,0xD9,0x95,0xEB,0xB7,0xC9,0xC3,0xFF,0x7E,0x7E,
    0x7E,0x7E,0xE3,0x9F,0xD1,0xAF,0xE7,0x99,0xD5,0xAB,0xE5,0x9B,0xC3,0xFF,0x7E,0x7E,
    0x7E,0x7E,0xC3,0xFF,0xD1,0xAF,0xE7,0x99,0xE5,0x9B,0xD5,0xAB,0xC3,0xFF,0x7E,0x7E,
    0x7E,0x7E,0xFF,0xFF,0xFF,0x9B,0xFF,0xA9,0xFF,0x9A,0xFF,0xA9,0xFF,0xFF,0x7E,0x7E,
    0x7E,0x7E,0xC3,0xFF,0xB1,0xCF,0xA7,0xD9,0x95,0xEB,0xB5,0xCB,0xC3,0xFF,0x7E,0x7E,
    0x7E,0x7E,0xC3,0xFF,0xC5,0xBB,0xA9,0xD7,0x91,0xEF,0x91,0xEF,0xC3,0xFF,0x7E,0x7E,
    0x7E,0x7E,0xC3,0xFF,0xF1,0x8F,0xA7,0xD9,0xC5,0xBB,0xF5,0x8B,0xC3,0xFF,0x7E,0x7E,
    0x7E,0x7E,0xFF,0xFF,0xFF,0x9B,0xFF,0xA9,0xFF,0xAA,0xFF,0xA9,0xFF,0xFF,0x7E,0x7E,
    0x7E,0x7E,0xFF,0xFF,0xFF,0x83,0xFB,0xAD,0xFF,0xAA,0xFB,0xAD,0xFF,0xFF,0x7E,0x7E,
    0x7E,0x7E,0xC3,0xFF,0xF1,0x8F,0xA7,0xD9,0xA5,0xDB,0xA7,0xD9,0xC3,0xFF,0x7E,0x7E,
    0x7E,0x7E,0xFF,0xFF,0xFF,0x9F,0xF7,0xAD,0xFF,0x95,0xF5,0xAB,0xFF,0xFF,0x7E,0x7E,
    0x7E,0x00,0xFF,0x00,0xFF,0xCA,0xFF,0xAA,0xFF,0xCE,0xFF,0xAA,0xFF,0x00,0x7E,0x00,
    0x7E,0x7E,0xC3,0xFF,0xF3,0x8D,0xD7,0xA9,0xEB,0x95,0xC7,0xB9,0xC3,0xFF,0x7E,0x7E,
    0x7E,0x7E,0xC3,0xFF,0xF7,0x89,0xD5,0xAB,0xF7,0x89,0xD7,0xA9,0xC3,0xFF,0x7E,0x7E,
    0x7E,0x7E,0xC3,0xFF,0xF3,0x8D,0xC7,0xB9,0xCB,0xB5,0xE7,0x99,0xC3,0xFF,0x7E,0x7E,
    0x7E,0x7E,0xC3,0xFF,0xA1,0xDF,0xAF,0xD1,0xAB,0xD5,0xAB,0xD5,0xC3,0xFF,0x7E,0x7E,
    0x7E,0x7E,0xC3,0xFF,0xE1,0x9F,0xCF,0xB1,0xAB,0xD5,0xEB,0x95,0xC3,0xFF,0x7E,0x7E,
    0x7E,0x7E,0xC3,0xFF,0xE9,0x97,0xCD,0xB3,0xAB,0xD5,0xED,0x93,0xC3,0xFF,0x7E,0x7E,
    0x7E,0x7E,0xC3,0xFF,0xF7,0x89,0xA7,0xD9,0xA5,0xDB,0xA7,0xD9,0xC3,0xFF,0x7E,0x7E,
    0x7E,0x7E,0xC3,0xFF,0x91,0xEF,0x91,0xEF,0x91,0xEF,0x91,0xEF,0xC3,0xFF,0x7E,0x7E,
    0x7E,0x7E,0xD3,0xAF,0xD7,0xA9,0xA7,0xD9,0xD5,0xAB,0xD7,0xA9,0xC3,0xFF,0x7E,0x7E,
    0x7E,0x7E,0xC3,0xFF,0xED,0x93,0xC9,0xB7,0xC5,0xBB,0xED,0x93,0xC3,0xFF,0x7E,0x7E,
    0x7E,0x7E,0xE3,0xDF,0xD7,0xA9,0xE3,0x9D,0xD7,0xA9,0xE7,0x99,0xC3,0xFF,0x7E,0x7E,
    0x7E,0x7E,0xC3,0xFF,0xC7,0xB9,0xC3,0xBD,0xC7,0xB9,0xF7,0x89,0xC3,0xFF,0x7E,0x7E,
    0x7E,0x7E,0xC3,0xFF,0xF7,0x89,0xC7,0xB9,0xC5,0xBB,0xF7,0x89,0xC3,0xFF,0x7E,0x7E,
    0x7E,0x7E,0xC3,0xFF,0xE1,0x9F,0xD7,0xA9,0xE5,0x9B,0xC5,0xBB,0xC3,0xFF,0x7E,0x7E,
    0x7E,0x7E,0xC3,0xFF,0xF3,0x8D,0xD7,0xA9,0xDB,0xA5,0xD7,0xA9,0xC3,0xFF,0x7E,0x7E,
    0x7E,0x00,0x81,0x00,0xCA,0xCA,0xB5,0xB5,0xD5,0xD5,0x95,0x95,0xC3,0x00,0x7E,0x00,
    0x7E,0x00,0xFF,0x00,0xFF,0xCA,0xFF,0x95,0xFF,0x55,0xFF,0xD5,0xFF,0x00,0x7E,0x00,
    0x7E,0x7E,0xC3,0xFF,0xE1,0x9F,0xEB,0x95,0xCB,0xB5,0xEF,0x91,0xC3,0xFF,0x7E,0x7E,
    0x7E,0x7E,0xC3,0xFF,0xF3,0x8D,0xC7,0xB9,0xDB,0xA5,0xF7,0x89,0xC3,0xFF,0x7E,0x7E,
    0x7E,0x7E,0xC3,0xFF,0xF5,0x8B,0xA7,0xD9,0xA4,0xDB,0xA7,0xD9,0xC3,0xFF,0x7E,0x7E,
    0x7E,0x7E,0xC3,0xFF,0xEB,0x95,0xD5,0xAB,0xD5,0xAB,0xE5,0x9B,0xC3,0xFF,0x7E,0x7E,
    0x7E,0x7E,0xC3,0xFF,0xD1,0xAF,0xD5,0xAB,0xFB,0x85,0xD5,0xAB,0xC3,0xFF,0x7E,0x7E,
    0x7E,0x7E,0xC3,0xFF,0xB1,0xCF,0xB7,0xC9,0xA5,0xDB,0xB5,0xCB,0xC3,0xFF,0x7E,0x7E,
    0x00,0x7E,0x00,0xFF,0xEA,0x15,0x55,0xAA,0x55,0xAA,0x55,0xAA,0x00,0xFF,0x00,0x7E,
    0x7E,0x7E,0xC3,0xFF,0xD5,0xAB,0xA5,0xDB,0xA7,0xD9,0xA7,0xD9,0xC3,0xFF,0x7E,0x7E,
    0x7E,0x7E,0xC3,0xFF,0xC1,0xBF,0xCB,0xB5,0xCB,0xB5,0xEF,0x91,0xC3,0xFF,0x7E,0x7E,
    0x7E,0x7E,0xC3,0xFF,0xD7,0xA9,0xD5,0xAB,0xF7,0x89,0xD5,0xAB,0xC3,0xFF,0x7E,0x7E,
    0x7E,0x7E,0xC3,0xFF,0xF7,0x89,0xA3,0xDD,0xA7,0xD9,0xA7,0xD9,0xC3,0xFF,0x7E,0x7E,
    0x7E,0x7E,0xC3,0xFF,0xAB,0xD5,0xAB,0xD5,0xAB,0xD5,0xBF,0xC1,0xC3,0xFF,0x7E,0x7E,
    0x7E,0x7E,0xC3,0xFF,0xE7,0x99,0xD7,0xA9,0xE5,0x9B,0xD7,0xA9,0xC3,0xFF,0x7E,0x7E,
    0x7E,0x7E,0xC3,0xFF,0xF7,0x89,0xD5,0xAB,0xD3,0xAD,0xF7,0x89,0xC3,0xFF,0x7E,0x7E,
    0x7E,0x7E,0xC3,0xFF,0xA1,0xDF,0xAD,0xD3,0xA9,0xD7,0xA9,0xD7,0xC3,0xFF,0x7E,0x7E,
    0x7E,0x7E,0xC3,0xFF,0xEF,0x91,0xD5,0xAB,0xE5,0x9B,0xC5,0xBB,0xC3,0xFF,0x7E,0x7E,
    0x7E,0x7E,0xFF,0xFF,0xFF,0x8F,0xFF,0xAA,0xFF,0x8A,0xFF,0xA8,0xFF,0xFF,0x7E,0x7E,
    0x7E,0x7E,0xC3,0xFF,0xD7,0xA9,0xD5,0xAB,0xF7,0x89,0xD7,0xA9,0xC3,0xFF,0x7E,0x7E,
    0x7E,0x7E,0xC3,0xFF,0xF5,0x8B,0xA5,0xDB,0xA5,0xDB,0xA7,0xD9,0xC3,0xFF,0x7E,0x7E,
    0x7E,0x7E,0xC3,0xFF,0xE5,0x9B,0xD7,0xA9,0xE5,0x9A,0xC7,0xB9,0xC3,0xFF,0x7E,0x7E,
    0x7E,0x7E,0xE3,0xDF,0xD1,0xAF,0xE5,0x9B,0xD5,0xAB,0xE5,0x9B,0xC3,0xFF,0x7E,0x7E,
    0x7E,0x7E,0xC3,0xFF,0xE1,0x9F,0xD5,0xAB,0xEB,0x95,0xC5,0xBB,0xC3,0xFF,0x7E,0x7E,
    0x7E,0x7E,0xC3,0xFF,0xAF,0xD1,0xD5,0xAB,0xF5,0x8B,0xD5,0xAB,0xC3,0xFF,0x7E,0x7E,
    0x7E,0x7E,0xC3,0xFF,0xE1,0x9F,0xD7,0xA9,0xEB,0x95,0xDB,0xA5,0xC3,0xFF,0x7E,0x7E,
    0x7E,0x7E,0xC3,0xFF,0xB1,0xCF,0xA7,0xD9,0xB5,0xCB,0xA5,0xDB,0xC3,0xFF,0x7E,0x7E,
    0x7E,0x00,0xFF,0x00,0xFF,0xC4,0xFF,0xAA,0xFF,0xCE,0xFF,0xAA,0xFF,0x00,0x7E,0x00,
    0x7E,0x7E,0xC3,0xFF,0xA1,0xDF,0xD7,0xA9,0xF5,0x8B,0xD7,0xA9,0xC3,0xFF,0x7E,0x7E,
    0x7E,0x7E,0xC3,0xFF,0xFB,0x85,0xAB,0xD5,0xAF,0xD1,0xAB,0xD5,0xC3,0xFF,0x7E,0x7E,
    0x7E,0x7E,0xC3,0xFF,0xE5,0x9B,0xDB,0xA5,0xEF,0x91,0xCB,0xB5,0xC3,0xFF,0x7E,0x7E,
    0x7E,0x7E,0xC3,0xFF,0xA5,0xDB,0xA5,0xDB,0xA5,0xDB,0xBD,0xC3,0xC3,0xFF,0x7E,0x7E,
    0x7E,0x00,0xFF,0x00,0xFF,0x66,0xFF,0x55,0xFF,0x56,0xFF,0x54,0xFF,0x00,0x7E,0x00,
    0x7E,0x00,0xFF,0x00,0xFF,0x60,0xFF,0x55,0xFF,0x65,0xFF,0x47,0xFF,0x00,0x7E,0x00,
    0x7E,0x00,0xFF,0x00,0xFF,0x4F,0xFF,0xAF,0xFF,0xEB,0xFF,0xAB,0xFF,0x00,0x7E,0x00,
    0x7E,0x00,0xFF,0x00,0xFF,0xCA,0xFF,0x95,0xFF,0x95,0xFF,0xD5,0xFF,0x00,0x7E,0x00,
    0x7E,0x7E,0xC3,0xFF,0xCB,0xB5,0xED,0x93,0xDD,0xA3,0xEB,0x95,0xC3,0xFF,0x7E,0x7E,
    0x7E,0x7E,0xC3,0xFF,0xF7,0x89,0xC5,0xBB,0xC7,0xB9,0xF5,0x8B,0xC3,0xFF,0x7E,0x7E,
    0x7E,0x7E,0xC3,0xFF,0xED,0x93,0xE9,0x97,0xC5,0xBB,0xED,0x93,0xC3,0xFF,0x7E,0x7E,
    0x7E,0x00,0xFF,0x00,0xFF,0xCA,0xFF,0x95,0xFF,0xD5,0xFF,0x95,0xFF,0x00,0x7E,0x00,
    0x7E,0x00,0xFF,0x00,0xFF,0x51,0xFF,0xAB,0xFF,0xAD,0xFF,0xAB,0xFF,0x00,0x7E,0x00,
    0x7E,0x00,0xFF,0x00,0xFF,0x90,0xFF,0xD2,0xFF,0xB5,0xFF,0x92,0xFF,0x00,0x7E,0x00,
    0x7E,0x7E,0xC3,0xFF,0xA1,0xDF,0xA7,0xD9,0xA5,0xDB,0xB5,0xCB,0xC3,0xFF,0x7E,0x7E,
    0x7E,0x7E,0xC3,0xFF,0xE7,0x99,0xD5,0xAB,0xE7,0x99,0xD5,0xAB,0xC3,0xFF,0x7E,0x7E,
    0x7E,0x7E,0xC3,0xFF,0xE5,0x9B,0xD7,0xA9,0xD4,0xAB,0xE7,0x99,0xC3,0xFF,0x7E,0x7E,
    0x7E,0x7E,0xC3,0xFF,0xE7,0x99,0xC9,0xB7,0xAB,0xD5,0xE7,0x99,0xC3,0xFF,0x7E,0x7E,
    0x7E,0x7E,0xE3,0xDF,0xDB,0xA5,0xEB,0x95,0xDF,0xA1,0xEB,0x95,0xC3,0xFF,0x7E,0x7E,
    0x7E,0x7E,0xC3,0xFF,0xD7,0xA9,0xD5,0xAB,0xF3,0x8D,0xD7,0xA9,0xC3,0xFF,0x7E,0x7E,
    0x7E,0x00,0xFF,0x00,0xFF,0x77,0xFF,0xAA,0xFF,0xAA,0xFF,0xAA,0xFF,0x00,0x7E,0x00,
    0x7E,0x7E,0xC3,0xFF,0xE7,0x99,0xD5,0xAB,0xD3,0xAD,0xE7,0x99,0xC3,0xFF,0x7E,0x7E,
    0x7E,0x00,0xFF,0x00,0xFF,0xC6,0xFF,0xA8,0xFF,0xCA,0xFF,0xA6,0xFF,0x00,0x7E,0x00,
    0x7E,0x7E,0xC3,0xFF,0xE1,0x9F,0xCD,0xB3,0xCB,0xB5,0xEB,0x95,0xC3,0xFF,0x7E,0x7E,
    0x7E,0x00,0xFF,0x00,0xFF,0x95,0xFF,0xD5,0xFF,0xB7,0xFF,0x95,0xFF,0x00,0x7E,0x00,
    0x7E,0x7E,0xC3,0xFF,0xB5,0xCB,0xA5,0xDB,0xB5,0xCB,0xA7,0xD9,0xC3,0xFF,0x7E,0x7E,
    0x7E,0x00,0xFF,0x00,0xFF,0x50,0xFF,0xAB,0xFF,0xAA,0xFF,0xAB,0xFF,0x00,0x7E,0x00,
    0x7E,0x7E,0xC3,0xFF,0xC1,0xBF,0xCB,0xB5,0xCB,0xB5,0xE5,0x9B,0xC3,0xFF,0x7E,0x7E,
    0x7E,0x7E,0xC3,0xFF,0xF7,0x89,0xA5,0xDB,0xA3,0xDD,0xA7,0xD9,0xC3,0xFF,0x7E,0x7E,
    0x7E,0x7E,0xC3,0xFF,0xA7,0xD9,0xD9,0xA7,0xDB,0xA5,0xA5,0xDB,0xC3,0xFF,0x7E,0x7E,
]   # Repeat the tiles to fill the 8x8 grid

class TileEditor:
    def __init__(self):
        self.screen = pygame.display.set_mode((WINDOW_SIZE, WINDOW_SIZE))
        pygame.display.set_caption("Game Boy Tile Editor")
        self.clock = pygame.time.Clock()
        
        # Initialize with example tile data
        self.tiles_data = EXAMPLE_TILES.copy()
        self.selected_color = 0
        self.running = True
        self.fill_mode = False
        
        # Add undo history
        self.undo_history = []
        self.max_undo_steps = 3
        
        # Calculate total number of tiles
        self.total_tiles = len(self.tiles_data) // 16
        
        # Calculate grid dimensions
        self.grid_width = min(TILES_PER_ROW, self.total_tiles)
        self.grid_height = (self.total_tiles + self.grid_width - 1) // self.grid_width
        
        # View position
        self.view_x = 0
        self.view_y = 0

    def save_state(self):
        """Save current state to undo history"""
        # Create a deep copy of current state
        state_copy = self.tiles_data.copy()
        
        # Add to history
        self.undo_history.append(state_copy)
        
        # Keep only last 3 states
        if len(self.undo_history) > self.max_undo_steps:
            self.undo_history.pop(0)

    def undo(self):
        """Restore previous state from undo history"""
        if self.undo_history:
            self.tiles_data = self.undo_history.pop()

    def get_pixel_color(self, tile_index, x, y):
        """Get the color value (0-3) for a pixel at (x,y) in the specified tile"""
        if tile_index >= self.total_tiles:
            return 0
            
        # Get the two bytes for this row
        byte1 = self.tiles_data[tile_index * 16 + y * 2]
        byte2 = self.tiles_data[tile_index * 16 + y * 2 + 1]
        
        # Extract the bits for this pixel
        bit1 = (byte1 >> (7 - x)) & 1
        bit2 = (byte2 >> (7 - x)) & 1
        
        # Combine bits to get color (0-3)
        return (bit2 << 1) | bit1
    
    def set_pixel_color(self, tile_index, x, y, color):
        """Set the color value (0-3) for a pixel at (x,y) in the specified tile"""
        if tile_index >= self.total_tiles:
            return
            
        # Save state before modification
        self.save_state()
            
        byte1_idx = tile_index * 16 + y * 2
        byte2_idx = tile_index * 16 + y * 2 + 1
        
        # Clear the bits at position x
        self.tiles_data[byte1_idx] &= ~(1 << (7 - x))
        self.tiles_data[byte2_idx] &= ~(1 << (7 - x))
        
        # Set the new bits
        if color & 1:  # Set bit1
            self.tiles_data[byte1_idx] |= (1 << (7 - x))
        if color & 2:  # Set bit2
            self.tiles_data[byte2_idx] |= (1 << (7 - x))
    
    def flood_fill(self, tile_index, x, y, target_color, replacement_color):
        """Flood fill algorithm for connected pixels of the same color"""
        if (tile_index >= self.total_tiles or
            x < 0 or x >= TILE_SIZE or
            y < 0 or y >= TILE_SIZE):
            return

        current_color = self.get_pixel_color(tile_index, x, y)
        if current_color != target_color or current_color == replacement_color:
            return

        # Set the pixel color without saving state
        byte1_idx = tile_index * 16 + y * 2
        byte2_idx = tile_index * 16 + y * 2 + 1
        
        # Clear the bits at position x
        self.tiles_data[byte1_idx] &= ~(1 << (7 - x))
        self.tiles_data[byte2_idx] &= ~(1 << (7 - x))
        
        # Set the new bits
        if replacement_color & 1:  # Set bit1
            self.tiles_data[byte1_idx] |= (1 << (7 - x))
        if replacement_color & 2:  # Set bit2
            self.tiles_data[byte2_idx] |= (1 << (7 - x))

        # Recursively fill connected pixels
        self.flood_fill(tile_index, x + 1, y, target_color, replacement_color)
        self.flood_fill(tile_index, x - 1, y, target_color, replacement_color)
        self.flood_fill(tile_index, x, y + 1, target_color, replacement_color)
        self.flood_fill(tile_index, x, y - 1, target_color, replacement_color)

    def draw_tiles(self):
        """Draw the current tile grid state"""
        self.screen.fill((128, 128, 128))  # Gray background
        
        # Draw grid
        for x in range(TILES_PER_ROW + 1):
            pygame.draw.line(self.screen, (64, 64, 64),
                           (x * TILE_SIZE * SCALE, 0), 
                           (x * TILE_SIZE * SCALE, WINDOW_SIZE))
        for y in range(TILES_PER_COL + 1):
            pygame.draw.line(self.screen, (64, 64, 64),
                           (0, y * TILE_SIZE * SCALE), 
                           (WINDOW_SIZE, y * TILE_SIZE * SCALE))
        
        # Calculate visible tiles based on view position
        start_tile = self.view_y * TILES_PER_ROW + self.view_x
        
        # Draw visible tiles
        for i in range(TILES_PER_ROW * TILES_PER_COL):
            tile_index = start_tile + i
            if tile_index >= self.total_tiles:
                break
                
            tile_x = i % TILES_PER_ROW
            tile_y = i // TILES_PER_ROW
            
            # Draw each pixel in the tile
            for y in range(TILE_SIZE):
                for x in range(TILE_SIZE):
                    color = self.get_pixel_color(tile_index, x, y)
                    pygame.draw.rect(self.screen, COLORS[color],
                                   (tile_x * TILE_SIZE * SCALE + x * SCALE + 1,
                                    tile_y * TILE_SIZE * SCALE + y * SCALE + 1,
                                    SCALE - 1, SCALE - 1))
        
        # Draw fill mode indicator
        if self.fill_mode:
            pygame.draw.circle(self.screen, (255, 0, 0), (WINDOW_SIZE - 10, 10), 5)
        
        pygame.display.flip()
    
    def run(self):
        while self.running:
            for event in pygame.event.get():
                if event.type == pygame.QUIT:
                    self.running = False
                
                elif event.type == pygame.KEYDOWN:
                    # Handle number keys for color selection
                    if event.key in [pygame.K_1, pygame.K_2, pygame.K_3, pygame.K_4]:
                        self.selected_color = event.key - pygame.K_1
                    # Handle arrow keys for navigation
                    elif event.key == pygame.K_LEFT:
                        self.view_x = max(0, self.view_x - 1)
                    elif event.key == pygame.K_RIGHT:
                        max_x = max(0, self.grid_width - TILES_PER_ROW)
                        self.view_x = min(max_x, self.view_x + 1)
                    elif event.key == pygame.K_UP:
                        self.view_y = max(0, self.view_y - 1)
                    elif event.key == pygame.K_DOWN:
                        max_y = max(0, self.grid_height - TILES_PER_COL)
                        self.view_y = min(max_y, self.view_y + 1)
                    # Handle P key for clipboard copy
                    elif event.key == pygame.K_p:
                        array_str = '[' + ','.join(f'0x{val:02X}' for val in self.tiles_data) + ']'
                        pyperclip.copy(array_str)
                        print(f"Copied {len(self.tiles_data)} bytes to clipboard!")
                    # Handle I key for fill mode toggle
                    elif event.key == pygame.K_i:
                        self.fill_mode = not self.fill_mode
                    # Handle Z key for undo
                    elif event.key == pygame.K_z:
                        self.undo()
                
                elif event.type == pygame.MOUSEBUTTONDOWN:
                    # Handle mouse clicks for pixel editing
                    if event.button == 1:  # Left click
                        x, y = event.pos
                        tile_x = x // (TILE_SIZE * SCALE)
                        tile_y = y // (TILE_SIZE * SCALE)
                        pixel_x = (x % (TILE_SIZE * SCALE)) // SCALE
                        pixel_y = (y % (TILE_SIZE * SCALE)) // SCALE
                        
                        # Calculate tile index
                        tile_index = (self.view_y * TILES_PER_ROW + self.view_x) + (tile_y * TILES_PER_ROW + tile_x)
                        
                        if (0 <= tile_index < self.total_tiles and
                            0 <= pixel_x < TILE_SIZE and
                            0 <= pixel_y < TILE_SIZE):
                            if self.fill_mode:
                                # Get the color of the clicked pixel
                                target_color = self.get_pixel_color(tile_index, pixel_x, pixel_y)
                                # Only fill if the target color is different from the selected color
                                if target_color != self.selected_color:
                                    # Save state once before starting the fill operation
                                    self.save_state()
                                    self.flood_fill(tile_index, pixel_x, pixel_y, target_color, self.selected_color)
                            else:
                                self.set_pixel_color(tile_index, pixel_x, pixel_y, self.selected_color)
            
            self.draw_tiles()
            self.clock.tick(60)
        
        pygame.quit()

if __name__ == "__main__":
    editor = TileEditor()
    editor.run() 